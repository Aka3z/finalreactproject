// Generated by CoffeeScript 1.7.1
(function() {
  var BACKOFF_MILLIS, ERRORCODES, ERROR_WAIT, ESLight, MAX_RETRIES, METHODS, NO_SHARD, Q, calcBackoff, extend, http, querys, slice, stream, url,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  url = require('url');

  Q = require('q');

  querys = require('querystring');

  stream = require('stream');

  slice = function(a) {
    return Array.prototype.slice.call(a, 0);
  };

  extend = function() {
    var key, object, objects, target, value, _i, _len;
    target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = objects.length; _i < _len; _i++) {
      object = objects[_i];
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        value = object[key];
        target[key] = value;
      }
    }
    return target;
  };

  ERROR_WAIT = 2000;

  MAX_RETRIES = 10;

  BACKOFF_MILLIS = 200;

  METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD'];

  NO_SHARD = 'NoShardAvailableActionException';

  ERRORCODES = ['ECONNREFUSED', 'ENETUNREACH', 'ECONNRESET', 'ETIMEDOUT'];

  ESLight = (function() {
    function ESLight() {
      var c, e, endpoints, _i, _len, _ref, _ref1;
      endpoints = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!endpoints.length) {
        throw 'expected endpoints';
      }
      e = endpoints;
      if (e.reduce((function(p, c) {
        return Array.isArray(c) || p;
      }), false)) {
        e = (_ref = []).concat.apply(_ref, e);
      }
      this._endpoints = e.map(function(c) {
        if (typeof c === 'string') {
          return url.parse(c);
        } else {
          return c;
        }
      });
      _ref1 = this._endpoints;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        c._count = 0;
      }
    }

    ESLight.prototype._parseExecArgs = function(oper, query, body) {
      var args, len, method, path, _ref;
      if (!oper) {
        throw 'bad args';
      }
      args = slice(arguments);
      len = args.length;
      if (len >= 2 && typeof args[len - 1] === 'object') {
        body = args[len - 1];
        len--;
      } else {
        body = void 0;
      }
      if (len >= 2 && typeof args[len - 1] === 'object') {
        query = args[len - 1];
        len--;
      } else {
        query = void 0;
      }
      oper = args.slice(0, len);
      method = 'GET';
      if (_ref = oper[0], __indexOf.call(METHODS, _ref) >= 0) {
        method = oper.shift();
      }
      if (!oper.length) {
        throw 'bad args';
      }
      path = oper.join('/');
      if ((path.indexOf('/')) !== 0) {
        path = '/' + path;
      }
      return [method, path, query, body];
    };

    ESLight.prototype.exec = function(oper, query, body) {
      var attempts, def, doAttempt, firstTry, lastErr, method, path, scheduleAttempt, _ref;
      _ref = this._parseExecArgs.apply(this, arguments), method = _ref[0], path = _ref[1], query = _ref[2], body = _ref[3];
      def = Q.defer();
      attempts = MAX_RETRIES;
      lastErr = null;
      firstTry = true;
      doAttempt = (function(_this) {
        return function() {
          var backoff, prom;
          if (--attempts <= 0) {
            def.reject(lastErr);
            return;
          }
          backoff = calcBackoff(MAX_RETRIES - attempts);
          prom = _this._tryReq(method, path, query, body, firstTry);
          firstTry = false;
          if (Q.isPromise(prom)) {
            return prom.then(function(res) {
              return def.resolve(res);
            }).fail(function(err) {
              var _ref1, _ref2, _ref3;
              if ((500 <= (_ref1 = err.statusCode) && _ref1 <= 599)) {
                lastErr = err;
                return scheduleAttempt(backoff);
              } else if (_ref2 = err.code, __indexOf.call(ERRORCODES, _ref2) >= 0) {
                lastErr = err;
                return scheduleAttempt(backoff);
              } else if (err === 'no retry') {
                return def.reject(lastErr);
              } else if (err instanceof Error) {
                return def.reject(err);
              } else if (err != null ? (_ref3 = err.body) != null ? _ref3.error : void 0 : void 0) {
                return def.reject(err);
              } else if (err != null ? err.statusCode : void 0) {
                return def.reject(err);
              } else {
                lastErr = err;
                return scheduleAttempt(backoff);
              }
            }).done();
          }
        };
      })(this);
      scheduleAttempt = (function(_this) {
        return function(backoff) {
          return setTimeout(doAttempt, backoff);
        };
      })(this);
      doAttempt();
      return def.promise;
    };

    ESLight.prototype._tryReq = function(method, path, query, body, firstTry) {
      var def, disable, endpoint, isUsable, maxcount;
      isUsable = function(e) {
        return !e._disabled || (new Date()).getTime() > e._wait;
      };
      maxcount = 0;
      endpoint = this._endpoints.reduce((function(prev, cur) {
        maxcount = Math.max(cur._count, maxcount);
        if (!prev || !(isUsable(prev)) || (isUsable(cur)) && cur._count < prev._count) {
          return cur;
        }
        return prev;
      }), null);
      def = Q.defer();
      if (isUsable(endpoint)) {
        if (endpoint._disabled) {
          endpoint._count = maxcount - 1;
          delete endpoint._disabled;
          delete endpoint._wait;
        }
      } else if (!firstTry) {
        def.reject('no retry');
        return def.promise;
      }
      endpoint._count++;
      disable = function() {
        endpoint._disabled = true;
        return endpoint._wait = (new Date()).getTime() + ERROR_WAIT;
      };
      (this._doReq(endpoint, method, path, query, body)).then(function(res) {
        return def.resolve(res.body);
      }).fail(function(res) {
        var available, _ref, _ref1;
        if (res.statusCode) {
          available = !((res != null ? (_ref = res.message) != null ? typeof _ref.indexOf === "function" ? _ref.indexOf(NO_SHARD) : void 0 : void 0 : void 0) === 0);
          if (available && (500 <= (_ref1 = res.statusCode) && _ref1 <= 599)) {
            disable();
          }
        }
        return def.reject(res);
      }).done();
      return def.promise;
    };

    ESLight.prototype._doReq = function(endpoint, method, path, query, body) {
      var opts;
      if (query) {
        path += '?' + querys.stringify(query);
      }
      opts = extend({}, endpoint, {
        method: method,
        path: path
      });
      if (body) {
        opts.headers = {
          'Content-Type': 'application/json'
        };
      }
      return this._dispatch(opts, body);
    };

    ESLight.prototype._dispatch = function(opts, body) {
      var def, req;
      def = Q.defer();
      req = http.request(opts, function(res) {
        body = null;
        res.setEncoding('utf-8');
        res.on('data', function(chunk) {
          if (!body) {
            body = '';
          }
          return body += chunk;
        });
        return res.on('end', function() {
          var err, _ref;
          if (body) {
            try {
              res.body = JSON.parse(body);
            } catch (_error) {
              err = _error;
              res.body = body;
            }
          }
          if ((200 <= (_ref = res.statusCode) && _ref <= 299)) {
            return def.resolve(res);
          } else {
            return def.reject(res);
          }
        });
      });
      if (body) {
        if (!(body instanceof Buffer) && typeof body !== 'string') {
          body = JSON.stringify(body);
        }
        body = new Buffer(body);
        req.setHeader('Content-Length', body.length);
        req.write(body);
      }
      req.on('error', function(err) {
        return def.reject(err);
      });
      req.end();
      return def.promise;
    };

    return ESLight;

  })();

  calcBackoff = function(attempt) {
    var k;
    k = Math.floor(Math.random() * Math.pow(2, attempt));
    return k * BACKOFF_MILLIS;
  };

  module.exports = ESLight;

}).call(this);
